/// <reference types="mongoose/types/aggregate" />
/// <reference types="mongoose/types/callback" />
/// <reference types="mongoose/types/collection" />
/// <reference types="mongoose/types/connection" />
/// <reference types="mongoose/types/cursor" />
/// <reference types="mongoose/types/document" />
/// <reference types="mongoose/types/error" />
/// <reference types="mongoose/types/expressions" />
/// <reference types="mongoose/types/helpers" />
/// <reference types="mongoose/types/middlewares" />
/// <reference types="mongoose/types/indexes" />
/// <reference types="mongoose/types/models" />
/// <reference types="mongoose/types/mongooseoptions" />
/// <reference types="mongoose/types/pipelinestage" />
/// <reference types="mongoose/types/populate" />
/// <reference types="mongoose/types/query" />
/// <reference types="mongoose/types/schemaoptions" />
/// <reference types="mongoose/types/schematypes" />
/// <reference types="mongoose/types/session" />
/// <reference types="mongoose/types/types" />
/// <reference types="mongoose/types/utility" />
/// <reference types="mongoose/types/validation" />
/// <reference types="mongoose/types/virtuals" />
/// <reference types="mongoose/types/inferschematype" />
import { DefaultSchemaOptions, FilterQuery, Model, MongooseBulkWriteOptions, ObtainDocumentType, ResolveSchemaOptions, SchemaDefinition, SchemaDefinitionType, SchemaOptions, UpdateQuery, UpdateWithAggregationPipeline } from "mongoose";
export declare class MongooseModelManager<S> {
    collection: string;
    protected model: Model<S>;
    constructor(collection: string, definition: ObtainDocumentType<any, S, DefaultSchemaOptions> | SchemaDefinition<SchemaDefinitionType<S>>, options?: SchemaOptions | ResolveSchemaOptions<any>);
    create(datum: S): Promise<import("mongoose").Document<unknown, {}, S> & {
        _id?: unknown;
    } & Required<{
        _id: unknown;
    }>>;
    createMany(data: S[]): Promise<any>;
    exists(filter: FilterQuery<S>): import("mongoose").Query<{
        _id: import("mongoose").InferId<S>;
    } | null, import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>, {}, S, "findOne">;
    find(filter: FilterQuery<S>): import("mongoose").Query<import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>> | null, import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>, {}, S, "findOne">;
    findMany(filter: FilterQuery<S>): import("mongoose").Query<import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>[], import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>, {}, S, "find">;
    batch(filter: FilterQuery<S>, from: number, size: number): import("mongoose").Query<import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>[], import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>, {}, S, "find">;
    updateOne(filter: FilterQuery<S>, data: UpdateWithAggregationPipeline | UpdateQuery<S>): any;
    bulkWrite(writes: any[], options?: MongooseBulkWriteOptions): Promise<any>;
    delete(filter: FilterQuery<S>): any;
    deleteMany(filter: FilterQuery<S>): any;
    countDocuments(filter: FilterQuery<S>): import("mongoose").Query<number, import("mongoose").IfAny<S, any, import("mongoose").Document<unknown, {}, S> & import("mongoose").Require_id<S>>, {}, S, "countDocuments">;
}
