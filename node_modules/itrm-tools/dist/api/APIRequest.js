"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIRequest = exports.RequestParameterType = exports.RequestContext = exports.RequestMethod = void 0;
const APIService_1 = require("./APIService");
const ServerSentEventsManager_1 = require("./channel/ServerSentEventsManager");
var RequestMethod;
(function (RequestMethod) {
    RequestMethod["GET"] = "GET";
    RequestMethod["POST"] = "POST";
    RequestMethod["PUT"] = "PUT";
    RequestMethod["DELETE"] = "DELETE";
})(RequestMethod || (exports.RequestMethod = RequestMethod = {}));
var RequestContext;
(function (RequestContext) {
    RequestContext["BODY"] = "body";
    RequestContext["HEADERS"] = "headers";
    RequestContext["PARAMS"] = "params";
    RequestContext["QUERY"] = "query";
})(RequestContext || (exports.RequestContext = RequestContext = {}));
var RequestParameterType;
(function (RequestParameterType) {
    RequestParameterType["STRING"] = "string";
    RequestParameterType["NUMBER"] = "number";
    RequestParameterType["BOOLEAN"] = "boolean";
    RequestParameterType["OBJECT"] = "object";
})(RequestParameterType || (exports.RequestParameterType = RequestParameterType = {}));
class APIRequest {
    constructor(method, config) {
        this.method = method;
        this.path = config.path;
        this.params = config.params;
        this.details = config.details;
        this.bodyParams = config.params.filter(param => { return param.context === RequestContext.BODY; });
    }
    getRequestDetails() {
        return {
            path: this.path,
            method: this.method,
            params: this.params,
            details: this.details,
            bodyParams: this.bodyParams
        };
    }
    process(req, res) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let request = APIService_1.ITRMAPIServiceGlobal.requests[APIRequest.buildKey(req)];
                let check = request.checkParameters(req);
                for (let key of Object.keys(check))
                    if (check[key].status !== 'OK')
                        return yield res.status(400).json(check[key]);
                return yield request.apply(req, res);
            }
            catch (error) {
                return yield res.status((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 500).json({
                    type: 'InternalRequestError',
                    error: 'An error has ocurred when procesing the request',
                    payload: (_d = (_c = error === null || error === void 0 ? void 0 : error.response) === null || _c === void 0 ? void 0 : _c.data) !== null && _d !== void 0 ? _d : error
                });
            }
        });
    }
    static buildKey(req) {
        if (req.route.path.includes(req.baseUrl))
            return req.method + "_" + req.route.path;
        return req.method + "_" + req.baseUrl + req.route.path;
    }
    checkParameters(req) {
        let result = this.checkItem(req, this.params);
        if (this.hasValidValuesProperty(req.body))
            result = this.checkValuesPropertyParameters(req);
        return result;
    }
    checkValuesPropertyParameters(req) {
        let result = {};
        for (let i = 0; i < req.body.values.length; i++) {
            result = this.checkItem({ body: req.body.values[i] }, this.bodyParams);
            if (result[RequestContext.BODY].status === 'Error') {
                result[RequestContext.BODY].message += ', item ' + (i + 1);
                return result;
            }
        }
        return result;
    }
    hasValidValuesProperty(context) {
        return context && context.values && Array.isArray(context.values);
    }
    checkItem(item, params) {
        let result = {};
        for (let group of params)
            if (item[group.context])
                result[group.context] = this.buildResponseMessage(result[group.context], group, this.findMissingParameters(item[group.context], group.properties));
            else
                return { status: 'Error', message: group.context + " was not found, check your express configuration" };
        return result;
    }
    buildResponseMessage(response, group, failures) {
        if (failures.missing.length > 0 || failures.wrongType.length > 0)
            return (response && response.blocked) ? response : { status: 'Error', message: this.buildMissingParametersMessage(group.context, failures.missing, failures.wrongType), blocked: group.properties.length > failures.missing.length };
        return { status: 'OK', blocked: true };
    }
    buildMissingParametersMessage(context, missing, wrongType) {
        let message = "Parameters";
        if (missing.length > 0) {
            message += this.buildMessage(missing);
            message += " were not found in " + context;
        }
        if (wrongType.length > 0) {
            message += missing.length > 0 ? " and" : "";
            message += this.buildMessage(wrongType);
            message += " have invalid type ";
        }
        return message;
    }
    buildMessage(array) {
        let message = "";
        for (let i = 0; i < array.length; i++)
            message += (i > 0 ? ", " : " ") + "'" + array[i] + "'";
        return message;
    }
    findMissingParameters(context, properties) {
        let missing = [];
        let wrongType = [];
        for (let property of properties)
            if (!context.hasOwnProperty(property.name))
                missing.push(property.name);
            else if (typeof context[property.name] !== property.type)
                wrongType.push(property.name);
        return { missing, wrongType };
    }
    openSentServerEvents(res) {
        return new ServerSentEventsManager_1.ServerSentEventsManager(res);
    }
}
exports.APIRequest = APIRequest;
//# sourceMappingURL=APIRequest.js.map