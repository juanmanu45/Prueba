"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentationRequest = void 0;
const DocumentationModels_1 = require("./DocumentationModels");
const APIService_1 = require("../../APIService");
class DocumentationRequest {
    constructor() { }
    init() {
        var _a;
        const { name, port, routers, requests } = (_a = APIService_1.ITRMAPIServiceGlobal.service) === null || _a === void 0 ? void 0 : _a.getServerInformation();
        DocumentationModels_1.defaultDocumentationSchema.info.title = name;
        DocumentationModels_1.defaultDocumentationSchema.servers = [{ url: `http://localhost:${port}` }];
        DocumentationModels_1.defaultDocumentationSchema.tags = this.createTagsObject(routers, name);
        DocumentationModels_1.defaultDocumentationSchema.paths = this.createPathsObject(requests, name);
        DocumentationModels_1.defaultDocumentationSchema.components = DocumentationModels_1.securitySchema.components;
        DocumentationModels_1.defaultDocumentationSchema.security = DocumentationModels_1.securityDeclaration.security;
        return DocumentationModels_1.defaultDocumentationSchema;
    }
    createTagsObject(routers, name) {
        let tags = [];
        for (let router in routers)
            tags.push({ name: router.replace("/", "") });
        tags.push({ name: name });
        return tags;
    }
    createPathsObject(requests, name) {
        var _a, _b, _c, _d;
        let paths = {};
        for (let request in requests) {
            let buildRequest = this.buildRequest(requests[request], request, name);
            paths[buildRequest.name] ? paths[buildRequest.name] : paths[buildRequest.name] = {};
            paths[buildRequest.name][buildRequest.requestMethod] = {
                tags: [buildRequest.tag],
                operationId: buildRequest.requestMethod + " " + (buildRequest.name).toLowerCase(),
                description: (_b = (_a = requests[request].details) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (buildRequest.name).toLowerCase(),
                summary: (_d = (_c = requests[request].details) === null || _c === void 0 ? void 0 : _c.description) !== null && _d !== void 0 ? _d : (buildRequest.name).toLowerCase(),
                parameters: buildRequest.params,
                responses: this.buildResponses(requests[request])
            };
            if ((buildRequest.requestMethod === "post" || buildRequest.requestMethod === "put") && requests[request].bodyParams.length > 0)
                paths[buildRequest.name][buildRequest.requestMethod].requestBody = this.buildBodyParams(requests[request].bodyParams);
        }
        return paths;
    }
    buildRequest(request, requestName, serviceName) {
        let name = requestName.replace(`${request.method}_`, "");
        name = name.replace(/:([^/]+)/g, '{$1}');
        let tag = name === request.path ? serviceName : name.split("/")[1];
        let requestMethod = request.method.toLowerCase();
        let buildParams = this.buildParams(request.getRequestDetails().params);
        return { name, tag, requestMethod, params: buildParams };
    }
    buildBodyParams(bodyParams) {
        let bodySchema = structuredClone(DocumentationModels_1.defaultBodySchema);
        for (let param of bodyParams) {
            let parameter = param.properties;
            parameter.forEach((element) => {
                bodySchema.content["application/json"].schema.properties[element.name] = { type: element.type };
            });
        }
        return bodySchema;
    }
    buildParams(params) {
        let parameters = [];
        if (params.length > 0) {
            for (let param of params) {
                let parameter = param.properties;
                parameter.forEach((element) => {
                    if (param.context !== "body") {
                        let body = {
                            name: element.name,
                            in: this.fixParamName(param.context),
                            schema: {
                                type: element.type
                            }
                        };
                        if (param.context === "params")
                            body.required = true;
                        parameters.push(body);
                    }
                });
            }
            return parameters;
        }
        return [];
    }
    fixParamName(name) {
        switch (name) {
            case "params":
                return "path";
            case "headers":
                return "header";
            default:
                return name;
        }
    }
    buildResponses(request) {
        var _a;
        let response = {};
        if (request.details) {
            for (let sample of request.details.samples) {
                response[sample.status] = {
                    description: (_a = DocumentationModels_1.httpStatusCodes[sample.status]) !== null && _a !== void 0 ? _a : "response",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: this.buildResponseProperties(sample)
                            }
                        }
                    }
                };
            }
            return response;
        }
        else
            return { "200": { description: "Successful response" } };
    }
    buildResponseProperties(sample) {
        let properties = {};
        for (let key in sample.output)
            properties[key] = { type: typeof (sample.output[key]), example: sample.output[key] };
        return properties;
    }
}
exports.DocumentationRequest = DocumentationRequest;
//# sourceMappingURL=DocumentationRequest.js.map